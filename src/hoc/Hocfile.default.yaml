commands:
  - name: flash
    optionals:
      - name: cached
        default: "true"
      - name: refetch
        default: "false"
    arguments: []
    procedure:
      - description: Fetch image
        script: |
          options=( 'Debian 20' )
          urls=(
            'https://cdimage.ubuntu.com/releases/20.04/release/ubuntu-20.04.3-live-server-arm64.iso'
          )

          STORE=index hoc in choose \
              --text '"Which image do you want to use?"' \
              --options "$( lines "${options[@]}" | stringify | listify)"

          image="${options[$index]}"
          url="${urls[$index]}"

          STORE=image_key hoc do snake_case --string "$(stringify "$image")"

          echo URL: "$url"

          {%- if input.cached == "true" %}
          filepath={{ cache_dir | squote }}"/$image_key"
          if [[ -e "$filepath" ]] ; then
              exists={% if input.refetch == "true" -%} 0 {%- else -%} 1 {%- endif %}
          else
              exists=0
          fi
          {%- else %}
          filepath="$(mktemp "$(echo "$TMPDIR/XXXXXXXXXXXX" | sed 's/\/\/*/\//g')")"
          exists=0
          {%- endif %}

          if [[ $exists = 0 ]] ; then
              echo "Fetching image ..."
              curl -s "$url" --output "$filepath"
              echo "Image saved to $filepath"
          else
              echo "Using cached image at $filepath"
          fi

          hoc out static --image "$(stringify "$image")"
          hoc out static --image_path "$(stringify "$filepath")"
          hoc out set --image_type '"disk"'
      - description: Find attached disks
        script: |
          echo "Finding attached disks ..."
          output="$(diskutil list external physical)"

          if [[ -z "$(trim "$output")" ]] ; then
              echo "No external disk attached"
              echo "Waiting for a drive to be attached ..."

              while [[ -z "$(trim "$output")" ]] ; do
                  sleep 1
                  output="$(diskutil list external physical)"
              done
          fi

          hoc out set --regex '"^ *#:( *TYPE) *(NAME *) (SIZE *)(IDENTIFIER *)$"'
          hoc out static --search_strings []
          echo "$output" | stringify | hoc out append --search_strings -
      - description: Match disk list header
        scriptRef: regex
      - description: Parse disk list header
        script: |
          {%- set filtered = [] %}
          {%- for m in input.matches %}
          {%- if m | length == 4 %}
          {%- set_global filtered = filtered | concat(with=[m]) %}
          {%- endif %}
          {%- endfor %}

          {%- if filtered | length != 1 %}
          echo "Disk list header output could not be parsed" >&2
          exit 1
          {%- endif %}

          ty_ln={{ filtered | nth(n=0) | nth(n=0) | length }}
          nm_ln={{ filtered | nth(n=0) | nth(n=1) | length }}
          sz_ln={{ filtered | nth(n=0) | nth(n=2) | length }}
          id_ln={{ filtered | nth(n=0) | nth(n=3) | length }}

          hoc out set --regex '"^ *0:(.{0,'$ty_ln'}) (.{0,'$nm_ln'}).(.{0,'$sz_ln'})(.{0,'$id_ln'})$"'
      - description: Match disk list
        scriptRef: regex
      - description: Flash image
        script: |
          hoc in unset --search_strings

          disks=(
              {%- set filtered = [] %}
              {%- for m in input.matches %}
              {%- if m | length == 4 %}
              {%- set_global filtered = filtered | concat(with=[m]) %}
              {{ m | nth(n=3) | trim | squote }}
              {%- endif %}
              {%- endfor %}
          )

          options=(
              {%- for f in filtered %}
              {%- set ty = f | nth(n=0) | trim %}
              {%- set nm = f | nth(n=1) | trim %}
              {%- set sz = f | nth(n=2) | trim | squote %}
              {%- set id = f | nth(n=3) | trim | squote %}

              {%- if ty == "" %}
              {%- set ty = "unknown type" | squote %}
              {%- else %}
              {%- set ty = "type " ~ ty | squote %}
              {%- endif %}

              {%- if nm == "" %}
              {%- set nm = "unnamed disk" | squote %}
              {%- else %}
              {%- set nm = nm | squote %}
              {%- endif %}

              {{ nm }}' of '{{ ty }}' with size '{{ sz }}' mounted at '{{ id }}
              {%- endfor %}
          )

          STORE=index hoc in choose \
              --text '"Which disk do you want to flash?"' \
              --options "$(lines "${options[@]:-}" | stringify | listify)"

          disk="/dev/r${disks[$index]}"

          echo "Unmounting $disk ..."
          diskutil unmountDisk "$disk"

          STORE=resp hoc in prompt \
              --text '"Do you want to continue to flash '$disk' with {{ input.image }}?"'
          if [[ $resp = 0 ]] ; then
              exit 1
          fi

          echo "Flashing $disk ..."
          sudo dd bs=1m if={{ input.image_path | squote }} of="$disk" 2>&1

          {%- if input.cached == "false" %}
          echo "Cleaning up temporary files ..."
          rm {{ input.image_path | squote }}
          {%- endif %}

  - name: configure
    optionals:
      - name: cidr
        default: 10.1.0.0/16
    arguments:
      - name: node-name
    procedure:
      - description: Find local endpoints
        script: |
          hoc out set --regex '"([^ ]+) \\((.+)\\) at ([^ ]+) on (.+) \\[(.+)\\]"'
          hoc out set --search_strings []

          echo "Searching for local endpoints ..."
          arp -a | stringify | hoc out append --search_strings -
      - description: Match endpoint output
        scriptRef: regex
      - description: Filter endpoints
        script: |
          hoc out set --endpoints []
          {%- for m in input.matches %}
          {%- if m|nth(n=0) != "?" %}
          hoc out append --endpoints '["{{ m | nth(n=0) }}","{{ m | nth(n=1) }}"]'
          {%- endif %}
          {%- endfor %}
      - description: Configure endpoint
        condition:
          expression: input.endpoints|length > 0
          message: No endpoints found to configure
        script: |
          # Prompt user for endpoint to configure.
          message='"Which endpoint do you want to configure?"'
          node_names=(
              {%- for m in input.endpoints %}
              {{ m | nth(n=0) | squote }}
              {%- endfor %}
          )
          options=(
              {%- for m in input.endpoints %}
              {{ m | nth(n=0) | squote }}' at '{{ m | nth(n=1) | squote }}
              {%- endfor %}
          )
          options="$(lines "${options[@]:-}" | stringify | listify)"
          STORE=index hoc in choose --text "$message" --options "$options"

          # Persist the endpoint.
          hoc state persist --node_name "$(stringify ${node_names[$index]})"

          # Determine credentials for SSH user.
          username={{ state.username | default(value="pi") | squote }}

          {%- if state.username %}
          echo "Using previously set up user '{{ state.username }}'"
          STORE=password hoc in hidden_input --text '"Password for {{ state.username }}"'
          {%- else %}
          echo "Using default credentials"
          password='raspberry'
          {%- endif %}

  - name: build
    arguments:
      - name: service
    optionals:
      - fromOptionalSet: git
    procedure:
      - builtIn: DockerBuild

  - name: publish
    arguments:
      - name: service
    optionals:
      - fromOptionalSet: git
    procedure:
      - builtIn: GitlabPublish

  - name: deploy
    arguments:
      - name: service
    optionals:
      - fromOptionalSet: git
    procedure:
      - builtIn: K8sDeploy

optionalSets:
  - name: git
    optionals:
      - name: branch
        default: master
      - name: protocol
        default: ssh
      - name: domain
        default: gitlab.com
      - name: project
        default: lidin-homepi

script:
  predefined:
    - name: regex
      description: Match search strings with regular expression
      source: |
        regex={{ input.regex | squote }}
        hoc out set --matches []

        {%- for search_string in input.search_strings %}
        [[ {{ search_string | squote }} =~ $regex ]]

        if [[ {% raw %} ${#BASH_REMATCH} {% endraw %} = 0 ]] ; then
            matches="[]"
        else
            matches="$(lines "${BASH_REMATCH[@]:1}" | stringify | listify)"
        fi

        hoc out append --matches "$matches"
        {%- endfor %}

  profile: |
    function _args {
        shift $1
        if [[ $# = 1 ]] ; then
            echo $1
        else
            cat
        fi
    }

    function _hocsync {
        IFS= read -r ${1:-} <{{ sync_pipe }} || true
    }

    function lines {
        printf "%s\n" "$@"
    }

    function escape {
        _args 2 "$@" | sed -r 's/((^|[^\\])(\\\\)*)'$1'/\1\\'$1'/g'
    }

    function squote {
        _args 1 "$@" | sed -r 's/('\'')/'\''\\\1'\''/' | sed -r 's/(.*)/'\''\1'\''/'
    }

    function trim {
        _args 1 "$@" | xargs
    }

    function stringify {
        _args 1 "$@" | escape '"' | sed -r 's/(.*)/"\1"/'
    }

    function listify {
        _args 1 "$@" | join_by ',' | sed -r 's/(.*)/[\1]/'
    }

    function prepend {
        _args 2 "$@" | sed -r "s/(.*)/$1\1/"
    }

    function append {
        _args 2 "$@" | sed -r "s/(.*)/\1$1/"
    }

    function join_by {
        local d=$1
        shift

        if [[ $# = 0 ]] ; then
            IFS= read -r out
            while IFS= read -r line ; do
                out="$out$line"
            done <<< "$(sed 's/^/'$d'/')"
            echo "$out"
        else
            local f=$1
            shift
            printf %s "$f" "${@/#/$d}" | append "\n"
        fi
    }

    function unimplemented {
        echo "not implemented" >&2
        exit 1
    }

    function hoc {
        local ns=$1
        shift
        local cmd=$1
        shift

        local prefix="[hoc]:$ns:$cmd"
        local re='^--(.+)$'

        local flag ; unset flag

        local cmd_args=()
        local current_args=()
        local num_stdin=0

        for arg in "$@" ; do
            [[ "$arg" =~ $re ]]

            if [[ -z ${flag+x} ]] ; then
                if [[ {% raw %} ${#BASH_REMATCH[@]} {% endraw %} = 0 ]] ; then
                    echo "expected flag, got value: $arg" >&2
                    return 1
                fi

                flag="${BASH_REMATCH[1]}"
            else
                if [[ "$arg" = "-" ]] ; then
                    num_stdin=$(( num_stdin + 1 ))

                    current_args+=( "$flag=" )
                    cmd_args+=( "$(join_by ',' "${current_args[@]:-}")" )
                    current_args=()

                    unset flag
                elif [[ {% raw %} ${#BASH_REMATCH[@]} {% endraw %} = 2 ]] ; then
                    current_args+=( "$flag" )
                    flag="$arg"
                else
                    current_args+=( "$flag=$arg" )
                    unset flag
                fi
            fi
        done

        if [[ -n ${flag+x} ]] ; then
            current_args+=( "$flag" )
        fi

        cmd_args+=( "$(join_by ',' "${current_args[@]:-}")" )

        if [[ $num_stdin = 0 ]] ; then
            echo "$prefix($(join_by ',' "${cmd_args[@]:-}"))"
            _hocsync ${STORE:-}
            return 0
        fi

        while true ; do
            local args="${cmd_args[0]}"
            for i in `seq 1 $num_stdin` ; do
                if ! IFS= read -r value ; then
                    return 0
                fi

                if [[ -z ${cmd_args[$i]+x} ]] ; then
                    args="$args$value"
                else
                    args="$(join_by ',' "$args$value" "${cmd_args[$i]}")"
                fi
            done

            echo "$prefix($args)"
            _hocsync ${STORE:-}
        done
    }
