commands:
  - name: flash
    optionals:
      - name: cached
        default: "false"
    arguments: []
    procedure:
      - builtIn: RpiFlash

  - name: configure
    optionals:
      - name: cidr
        default: 10.1.0.0/16
    arguments:
      - name: node-name
    procedure:
      - script: |
          echo '[hoc]:out:set(regex="([^ ]*) \\((.*)\\) at ([^ ]*) on (.*) \\[(.*)\\]")'
          echo '[hoc]:out:set(search_strings=[])'
          echo "$(arp -a | dquote | prepend '[hoc]:out:append(search_strings=' | append ')')"
      - fromScript: regex
      - script: |
          message='"Which endpoint do you want to configure?"'

          options=""
          {%- for match in matches %}

          {%- if loop.index > 1 %}
          options="$options,"
          {%- endif %}

          options=$options\"
          options=$options{{ match | nth(n=0) | squote }}
          options=$options' at '
          options=$options{{ match | nth(n=1) | squote }}
          options=$options' connected via '
          options=$options{{ match | nth(n=4) | squote }}
          options=$options\"

          {%- endfor %}

          echo "[hoc]:in:choose(message=$message,options=$(echo $options | bracket))"
          read -r index <{{ sync_pipe }}

  - name: build
    arguments:
      - name: service
    optionals:
      - fromOptionalSet: git
    procedure:
      - builtIn: DockerBuild

  - name: publish
    arguments:
      - name: service
    optionals:
      - fromOptionalSet: git
    procedure:
      - builtIn: GitlabPublish

  - name: deploy
    arguments:
      - name: service
    optionals:
      - fromOptionalSet: git
    procedure:
      - builtIn: K8sDeploy

optionalSets:
  - name: git
    optionals:
      - name: branch
        default: master
      - name: protocol
        default: ssh
      - name: domain
        default: gitlab.com
      - name: project
        default: lidin-homepi

script:
  profile: |
    function lines {
        printf "%s\n" $@
    }

    function _args {
        shift $1
        if [[ $# = 1 ]] ; then
            echo $1
        else
            cat
        fi
    }

    function escape {
        _args 2 "$@" | sed -r 's/((^|[^\\])(\\\\)*)'$1'/\1\\'$1'/g'
    }

    function squote {
        _args 1 "$@" | sed -r 's/('\'')/'\''\\\1'\''/' | sed -r 's/(.*)/'\''\1'\''/'
    }

    function dquote {
        _args 1 "$@" | escape '"' | sed -r 's/(.*)/"\1"/'
    }

    function bracket {
        _args 1 "$@" | sed -r 's/(.*)/[\1]/'
    }

    function prepend {
        _args 2 "$@" | sed -r "s/(.*)/$1\1/"
    }

    function append {
        _args 2 "$@" | sed -r "s/(.*)/\1$1/"
    }

    function join_by {
        local d=$1
        shift

        if [[ $# = 0 ]] ; then
            read -r out
            while IFS= read -r line ; do
                out="$out$line"
            done <<< "$(sed 's/^/'$d'/')"
            echo "$out"
        else
            local f=$1
            shift
            printf %s "$f" "${@/#/$d}"
        fi
    }
  predefined:
    - name: regex
      source: |
        regex={{ regex | squote }}
        echo "[hoc]:out:set(matches=[])"

        {%- for search_string in search_strings %}
        [[ {{ search_string | squote }} =~ $regex ]]

        matches=$(lines ${BASH_REMATCH[@]:1} | dquote | join_by ',')
        echo "[hoc]:out:append(matches=[$matches])"
        {%- endfor %}

        echo "[hoc]:in:unset(regex)"
        echo "[hoc]:in:unset(search_strings)"
